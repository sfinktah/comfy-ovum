/// <reference lib="es2015.collection" />
/** @typedef {import("@comfyorg/litegraph/dist/LGraphNode").LGraphNode} LGraphNode */
/** @typedef {import("@comfyorg/litegraph/dist/LLink").LLink} LLink */
/** @typedef {import("@comfyorg/litegraph/dist/interfaces").INodeInputSlot} INodeInputSlot */
/** @typedef {import("@comfyorg/litegraph/dist/interfaces").INodeOutputSlot} INodeOutputSlot */
/** @typedef {import("@comfyorg/litegraph/dist/interfaces").ISlotType} ISlotType */
/** @typedef {import("@comfyorg/litegraph/dist/litegraph").LiteGraph} LiteGraph */
/** @typedef {import("@comfyorg/litegraph/dist/types/serialisation").SubgraphIO} SubgraphIO */
/** @typedef {import('@comfyorg/comfyui-frontend-types').ComfyApp} ComfyApp */
/** @typedef {import('@comfyorg/litegraph/dist/litegraph').LGraphCanvas} LGraphCanvas */
/** @typedef {import('@comfyorg/litegraph/dist/litegraph').LGraph} LGraph */
/** @typedef {import('@comfyorg/litegraph/dist/litegraph').LLink} LLink */
/** @typedef {import('@comfyorg/litegraph/dist/litegraph').NodeInputSlot} NodeInputSlot */
/** @typedef {import('@comfyorg/litegraph/dist/litegraph').NodeOutputSlot} NodeOutputSlot */
/** @typedef {import('@comfyorg/litegraph/dist/litegraph').Subgraph} Subgraph */
/** @typedef {import("../../typings/ComfyNode").ComfyNode} ComfyNode */
/** @typedef {import("../common/graphHelpersForTwinNodes.js").GraphHelpers} GraphHelpers */
/** @typedef {import("@comfyorg/litegraph/dist/types/widgets").IWidget} IWidget */
/** @typedef {import("@comfyorg/litegraph/dist/litegraph").ContextMenuItem} ContextMenuItem */
/** @typedef {import("@comfyorg/litegraph/dist/litegraph").SerializedLGraphNode} SerializedLGraphNode */

import { app } from "../../../scripts/app.js";
import { GraphHelpers } from "../common/graphHelpersForTwinNodes.js";
import { analyzeNamesForAbbrev, computeTwinNodeTitle, extractWidgetNames } from "../01/stringHelper.js";
import {
    setColorAndBgColor,
    isUnlinkedName,
    stripUnlinkedPrefix,
    makeUnlinkedName,
    wrapWidgetValueSetter,
    showAlert,
    findSetters,
    findSetter,
    ensureWidgetCount,
    normalizeWidgetLabels,
    validateNodeLinks,
    getPreviousWidgetName,
    ensureSlotCounts
} from "../01/twinnodeHelpers.js";
import { TwinNodes } from "../common/twinNodes.js";

// mostly written by GPT-5
// based on KJ's SetGet: https://github.com/kj-comfy/ComfyUI-extensions which was
// based on diffus3's SetGet: https://github.com/diffus3/ComfyUI-extensions

// Note: we don't actually have a settings , so lets use Kijai's
let disablePrefix = app.ui.settings.getSettingValue("KJNodes.disablePrefix")
const LGraphNode = LiteGraph.LGraphNode

app.registerExtension({
    name: "GetTwinNodes",
    // The setup() function was manually added, and is the only part of the extension that was not generated by AI,
    // but stolen directly from Kijai's code instead. Obviously I could have instructed AI to copy it for me, but I
    // forgot.
    async setup() {
        const value = 'top';
        const valuesToAddToIn = ["GetTwinNodes"];
        const valuesToAddToOut = ["SetTwinNodes"];
        // Remove entries if they exist
        for (const arr of Object.values(LiteGraph.slot_types_default_in)) {
            for (const valueToAdd of valuesToAddToIn) {
                const idx = arr.indexOf(valueToAdd);
                if (idx !== -1) {
                    arr.splice(idx, 1);
                }
            }
        }

        for (const arr of Object.values(LiteGraph.slot_types_default_out)) {
            for (const valueToAdd of valuesToAddToOut) {
                const idx = arr.indexOf(valueToAdd);
                if (idx !== -1) {
                    arr.splice(idx, 1);
                }
            }
        }
        if (value != "disabled") {
            for (const arr of Object.values(LiteGraph.slot_types_default_in)) {
                for (const valueToAdd of valuesToAddToIn) {
                    const idx = arr.indexOf(valueToAdd);
                    if (idx !== -1) {
                        arr.splice(idx, 1);
                    }
                    if (value === "top") {
                        arr.unshift(valueToAdd);
                    } else {
                        arr.push(valueToAdd);
                    }
                }
            }

            for (const arr of Object.values(LiteGraph.slot_types_default_out)) {
                for (const valueToAdd of valuesToAddToOut) {
                    const idx = arr.indexOf(valueToAdd);
                    if (idx !== -1) {
                        arr.splice(idx, 1);
                    }
                    if (value === "top") {
                        arr.unshift(valueToAdd);
                    } else {
                        arr.push(valueToAdd);
                    }
                }
            }
        }
    },
    registerCustomNodes() {
        class GetTwinNodes extends TwinNodes {

            defaultVisibility = true;
            serialize_widgets = true;
            drawConnection = false;
            slotColor = "#FFF";
            currentSetter = null;
            canvas = app.canvas;
            numberOfInputSlots = 0;

            /**
             * Constructs a new GetTwinNodes instance.
             * Mirrors the LGraphNode constructor semantics by creating a node with an optional title and initializing defaults.
             * @param {string} title Optional title displayed in the editor UI.
             */
            constructor(title) {
                super(title)
                if (!this.properties) {
                    this.properties = { constCount: 2 };
                } else if (this.properties.constCount == null) {
                    this.properties.constCount = 2;
                }
                this.properties.showOutputText = GetTwinNodes.defaultVisibility;
                const node = this;

                // Determine colors using all connected input types in order
                this.updateTitle();

                // Return combined constant names from SetTwinNodes and Kijai's SetNode (prefixed)
                this.getCombinedConstantNames = function() {
                    const names = [];

                    // Gather from SetTwinNodes (all widget values)
                    const setTwinNodes = GraphHelpers.getNodesByType(node.graph, 'SetTwinNodes');
                    for (const s of setTwinNodes) {
                        const ws = s.widgets || [];
                        for (const w of ws) {
                            if (w?.value) names.push(String(w.value));
                        }
                    }

                    const uniq = Array.from(new Set(names)).sort();
                    // Add reset option to allow unsetting the selection
                    uniq.unshift("(unset)");
                    return uniq;
                };

                // Ensure there are at least N combo widgets for constants, each with a values provider
                this.ensureGetterWidgetCount = function(count) {
                    ensureWidgetCount(this, count, "combo", "Constant", () => {
                        this.onRename();
                    }, {
                        values: () => {
                            return this.getCombinedConstantNames();
                        }
                    });
                    // Normalize widget labels to Constant 1, Constant 2, ...
                    this.normalizeGetterWidgetLabels();
                };

                // Ensure the number of outputs matches count
                ensureSlotCounts(this);

                // Normalize widget labels to "Constant N"
                this.normalizeGetterWidgetLabels = function() {
                    normalizeWidgetLabels(this, "Constant");
                };

                // ~Start with one selector; expand after matching a setter~
                const initialCount = this.properties.constCount || 2;
                this.ensureGetterWidgetCount(initialCount);

                // Ensure default outputs exist with type "*"
                for (let i = 0; i < initialCount; i++) {
                    if (this.outputs?.[i]) {
                        this.outputs[i].name = "*";
                        this.outputs[i].type = "*";
                        this.outputs[i].label = "*";
                    }
                }

                // During deserialization, respect serialized widgets/outputs by suppressing auto-derivation for a tick
                /**
                 * Called after the node has been configured or deserialized.
                 * Aligns with LGraphNode.onConfigure; used here to temporarily suppress auto-derivation after restore.
                 * @param {SerializedLGraphNode} _data The deserialized configuration data for this node.
                 * @returns {void}
                 */
                this.onConfigure = function(_data) {
                    console.log("[GetTwinNodes] onConfigure");
                    this.__restoring = true;
                    // Clear restoration flag shortly after configuration to allow normal behavior thereafter
                    setTimeout(() => { this.__restoring = false; }, 1000);
                };

                /**
                 * Called when a connection is created or removed for this node.
                 * Mirrors LGraphNode.onConnectionsChange semantics.
                 * @param {number} slotType LiteGraph.INPUT (1) for input, LiteGraph.OUTPUT (2) for output.
                 * @param {number} slot The slot index being affected.
                 * @param {boolean} isChangeConnect True when connecting; false when disconnecting.
                 * @param {LLink|null|undefined} link_info The link descriptor involved in the change.
                 * @param {INodeInputSlot|INodeOutputSlot|SubgraphIO} output The slot object for the affected side.
                 * @returns {void}
                 */
                this.onConnectionsChange = function(
                    slotType,
                    slot,
                    isChangeConnect,
                    link_info,
                    output
                ) {
                    // Respect serialized data on restore: skip auto-derive during deserialization
                    console.log("[GetTwinNodes] onConnectionsChange");
                    if (this.__restoring) { console.log("[GetTwinNodes] aborted due to __restoring state"); return; }

                    this.validateLinks();

                    // If an output is connected and the constant for that slot is unset,
                    // auto-select if there's only one known option for that index.
                    if (slotType === LiteGraph.OUTPUT && isChangeConnect) {
                        // When connecting the FIRST output and widget[0] is unset, and there are no other links,
                        // derive widget[0] from the target input's label/name/type.
                        // TODO: Check - auto-derive is intentionally limited to first output slot (slot 0)
                        if (slot === 0 && (!this.widgets?.[0]?.value || this.widgets[0].value === '*')) {
                            // Count total links across all outputs (after this connect)
                            let totalLinks = 0;
                            if (Array.isArray(this.outputs)) {
                                for (const out of this.outputs) {
                                    totalLinks += (out?.links?.length || 0);
                                }
                            }
                            if (totalLinks === 1 && link_info) {
                                // Try to read the target node and its input slot
                                const targetNode = GraphHelpers.getNodeById(node.graph, link_info.target_id);
                                const inSlot = targetNode?.inputs?.[link_info.target_slot];
                                const preferred =
                                    (inSlot?.label && String(inSlot.label).trim()) ||
                                    (inSlot?.name && String(inSlot.name).trim()) ||
                                    (inSlot?.type && String(inSlot.type).trim()) ||
                                    "";
                                if (preferred) {
                                    // If the derived name is not present in any known constants, append '*'
                                    let knownNames = this.getCombinedConstantNames()
                                        .filter(n => n && n !== "(unset)");
                                    const known = new Set(knownNames);
                                    const needsUnlinked = !known.has(preferred);
                                    this.widgets[0].value = needsUnlinked ? makeUnlinkedName(preferred) : preferred;
                                }
                            }
                        }

                        const idx = slot;
                        const val = this.widgets?.[idx]?.value;
                        const allSetters = GraphHelpers.getNodesByType(node.graph, 'SetTwinNodes');
                        const options = Array.from(new Set(
                            allSetters.map(s => s.widgets?.[idx]?.value).filter(Boolean)
                        ));
                        if ((!val || val === '*') && options.length === 1) {
                            if (this.widgets?.[idx]) this.widgets[idx].value = options[0];
                        }

                        // Attempt to auto-pair remaining constants from a matched setter
                        const matched = findSetter(node);
                        if (matched) {
                            const needed = matched.widgets?.length || 0;
                            const min = this.properties?.constCount || 2;
                            this.ensureGetterWidgetCount(Math.max(min, needed));
                            for (let i = 0; i < needed; i++) {
                                if (!this.widgets?.[i]?.value && matched.widgets?.[i]?.value) {
                                    this.widgets[i].value = matched.widgets[i].value;
                                }
                            }
                        }
                        this.onRename();
                    }

                    // Also refresh on output disconnects to update color/title when links are removed
                    if (slotType === LiteGraph.OUTPUT && !isChangeConnect) {
                        this.onRename();
                    }
                    
                    this.updateTitle();
                }

                // Backward-compatible single-name setter
                this.setName = function(name) {
                    console.log("[GetTwinNodes] setName should not have been called");
                    if (this.widgets?.[0]) {
                        this.widgets[0].value = name;
                    }
                    node.onRename();
                    node.serialize();
                }

                // New names setter (array-based) for arbitrary number of names
                this.setNamesArray = function(names) {
                    const min = this.properties?.constCount || 2;
                    const targetCount = Math.max(min, Array.isArray(names) ? names.length : 0);
                    this.ensureGetterWidgetCount(targetCount);
                    const count = Array.isArray(names) ? names.length : 0;
                    for (let i = 0; i < count; i++) {
                        if (node.widgets?.[i]) {
                            node.widgets[i].value = names[i];
                        }
                    }
                    node.onRename();
                    node.serialize();
                }
                // Backward-compatible two-name setter
                this.setNames = function(nameA, nameB) {
                    this.setNamesArray([nameA, nameB]);
                }


                /* During a reload:
                    [GetTwinNodes] onConnectionsChange
                    [GetTwinNodes] onRename
                    [GetTwinNodes] ensureOutputCount
                    [GetTwinNodes] onConfigure
                 */
                this.onRename = function() {
                    // Respect serialized data on restore: skip auto-derive during deserialization
                    console.log("[GetTwinNodes] onRename");
                    if (this.__restoring) { console.log("[GetTwinNodes] aborted due to __restoring state"); return; }

                    // Support "(unset)" option: clear widget value and possibly remove the first extra unset widget and its output
                    const RESET_LABEL = "(unset)";
                    let didUnset = false;
                    if (Array.isArray(this.widgets)) {
                        for (let i = 0; i < this.widgets.length; i++) {
                            if (this.widgets[i] && this.widgets[i].value === RESET_LABEL) {
                                // Disconnect links for this widget's corresponding output immediately
                                if (this.outputs?.[i]?.links?.length) {
                                    const links = [...this.outputs[i].links];
                                    for (const linkId of links) {
                                        const link = GraphHelpers.getLink(node.graph, linkId);
                                        if (link) GraphHelpers.removeLink(node.graph, linkId);
                                    }
                                }
                                // Clear to empty string immediately and refresh UI
                                this.widgets[i].value = '';
                                didUnset = true;
                            }
                        }
                        if (didUnset && app?.canvas?.setDirty) {
                            app.canvas.setDirty(true, true);
                        }
                    }
                    if (didUnset) {
                        // Find all unset widgets (empty string or falsy)
                        const unsetIndices = [];
                        for (let i = 0; i < (this.widgets?.length || 0); i++) {
                            const v = this.widgets?.[i]?.value;
                            if (!v) unsetIndices.push(i);
                        }

                        // Disconnect links for every unset widget's corresponding output
                        for (const idx of unsetIndices) {
                            if (this.outputs?.[idx]?.links?.length) {
                                const links = [...this.outputs[idx].links];
                                for (const linkId of links) {
                                    const link = GraphHelpers.getLink(node.graph, linkId);
                                    if (link) GraphHelpers.removeLink(node.graph, linkId);
                                }
                            }
                        }

                        if (unsetIndices.length > 1) {
                            // Remove the first unset widget and its corresponding output slot
                            const removeIdx = unsetIndices[0];
                            this.removeOutput(removeIdx);
                            if (Array.isArray(this.widgets)) {
                                this.widgets.splice(removeIdx, 1);
                            }
                            // Recompute node size after removal
                            this.size = this.computeSize();
                        }

                        // Always normalize labels after unset/removal
                        this.normalizeGetterWidgetLabels();
                        // Keep outputs count aligned to widgets after any removals
                        ensureSlotCounts(this);
                    }

                    const setter = findSetter(node);
                    // Gather current selections
                    const selected = (this.widgets || []).map(w => (w?.value ? String(w.value).trim() : ""));
                    const anySelected = selected.some(v => !!v);

                    if (setter) {
                        const setterNames = (setter.widgets || []).map(w => (w?.value ? String(w.value).trim() : ""));
                        // Map selected constant -> type (from matched setter input at that label)
                        const typeByConst = {};
                        setterNames.forEach((name, idx) => {
                            const t = setter.inputs?.[idx]?.type || '*';
                            if (name) typeByConst[name] = t;
                        });

                        // Ensure enough widgets and outputs
                        const wNeeded = setter.widgets?.length || 0;
                        this.ensureGetterWidgetCount(wNeeded || 2);
                        ensureSlotCounts(this);

                        // Autofill any empty selections from the matched setter (position-agnostic)
                        // Only perform this when we didn't just unset a widget via "(unset)".
                        if (!didUnset) {
                            const setterVals = (setter.widgets || []).map(w => (w?.value ? String(w.value).trim() : "")).filter(Boolean);
                            const selectedVals = new Set(
                                (this.widgets || []).map(w => (w?.value ? String(w.value).trim() : "")).filter(Boolean)
                            );
                            for (let i = 0; i < wNeeded; i++) {
                                if (this.widgets?.[i] && (!this.widgets[i].value || this.widgets[i].value === '*')) {
                                    const next = setterVals.find(v => !selectedVals.has(v));
                                    if (next) {
                                        this.widgets[i].value = next;
                                        selectedVals.add(next);
                                    }
                                }
                            }
                            // If only one constant is selected, ensure at least constCount widgets exist
                            const selectedCount = Array.from(selectedVals).length;
                            const min = this.properties?.constCount || 2;
                            if (selectedCount === 1 && (this.widgets?.length || 0) < min) {
                                this.ensureGetterWidgetCount(min);
                            }
                        } else {
                            // If didUnset but we still have only one selected and have fewer than min widgets, ensure additional empty widgets
                            const valList = (this.widgets || []).map(w => (w?.value ? String(w.value).trim() : "")).filter(Boolean);
                            const min = this.properties?.constCount || 2;
                            if (valList.length === 1 && (this.widgets?.length || 0) < min) {
                                this.ensureGetterWidgetCount(min);
                            }
                        }

                        // Normalize labels after any additions
                        this.normalizeGetterWidgetLabels();

                        // Set each output's name to the selected constant text and type from matched setter
                        const outCount = this.widgets?.length || 0;
                        let pickedType = null;
                        for (let i = 0; i < outCount; i++) {
                            const label = this.widgets?.[i]?.value ? String(this.widgets[i].value).trim() : "";
                            const t = label ? (typeByConst[label] || '*') : '*';

                            // Ensure output slot exists
                            if (i >= (this.outputs?.length || 0)) ensureSlotCounts(this);

                            if (this.outputs?.[i]) {
                                this.outputs[i].name = label || '*';
                                this.outputs[i].label = label || '*';
                                this.outputs[i].type = t;
                            }
                            if (!pickedType && label && t && t !== '*') {
                                pickedType = t;
                            }
                        }

                        // Note: we don't actually have a settings panel yet
                        // Only colorize when a constant is selected; follow same rule as SetTwinNodes (based on types)
                        const autoColor = app.ui.settings.getSettingValue("KJNodes.nodeAutoColor");
                        const typesArr = (this.outputs || []).map(o => o?.type).filter(t => t && t !== '*');
                        if (anySelected && autoColor && typesArr.length) {
                            setColorAndBgColor.call(this, typesArr);
                        } else {
                            // reset to default look if no selection, unknown type, or auto-color disabled
                            this.color = undefined;
                            this.bgcolor = undefined;
                        }
                    } else {
                        // No matching setter: if exactly one constant is selected, ensure we have a second empty widget
                        const selectedVals = (this.widgets || [])
                            .map(w => (w?.value ? String(w.value).trim() : ""))
                            .filter(Boolean);
                        const min = this.properties?.constCount || 2;
                        if (selectedVals.length === 1 && (this.widgets?.length || 0) < min) {
                            this.ensureGetterWidgetCount(min); // adds empty widgets up to min
                        }

                        ensureSlotCounts(this);
                    }

                    // Finally, validate existing links against updated types
                    this.validateLinks();
                }

                /**
                 * Creates a copy of this node.
                 * Conforms to LGraphNode.clone by returning a cloned node instance with size recomputed.
                 * @this {ComfyNode}
                 * @returns {ComfyNode} The cloned node.
                 */
                this.clone = function () {
                    const cloned = GetTwinNodes.prototype.clone.apply(this);
                    cloned.size = cloned.computeSize();
                    return cloned;
                };

                this.validateLinks = function() {
                    validateNodeLinks(this);
                };

                // Return the previous name recorded for the widget at index 'idx'
                this.getPreviousName = function(idx) {
                    return getPreviousWidgetName(this, idx);
                };

                // Listen for broadcast rename events and update matching widget values
                this.setnodeNameChange = function(old_value, value, widgetIndex, senderNodeId) {
                    console.log("[GetTwinNodes] setnodeNameChange", old_value, value);
                    const prev = (old_value != null) ? String(old_value).trim() : "";
                    const next = (value != null) ? String(value).trim() : "";
                    if (!prev || !next || prev === next) return;

                    let changed = false;
                    if (Array.isArray(this.widgets)) {
                        for (let i = 0; i < this.widgets.length; i++) {
                            const val = this.widgets[i]?.value != null ? String(this.widgets[i].value).trim() : "";
                            if (val && val === prev) {
                                this.widgets[i].value = next;
                                changed = true;
                            }
                        }
                    }
                    if (changed) {
                        if (typeof this.onRename === "function") this.onRename();
                        if (app?.canvas?.setDirty) app.canvas.setDirty(true, true);
                    }
                };

                // Support arbitrary number of types
                this.setTypesArray = function(typesArr) {
                    const min = this.properties?.constCount || 2;
                    const targetCount = Math.max(min, Array.isArray(typesArr) ? typesArr.length : 0);
                    ensureSlotCounts(this);
                    for (let i = 0; i < targetCount; i++) {
                        const t = (typesArr && typesArr[i]) ? typesArr[i] : '*';
                        if (this.outputs?.[i]) {
                            this.outputs[i].name = t;
                            this.outputs[i].type = t;
                        }
                    }
                    this.validateLinks();
                }

                // Backward-compatible two-slot setter delegates to array-based version
                this.setTypes = function(typeA, typeB) {
                    this.setTypesArray([typeA, typeB]);
                }

                // TODO: Check - legacy single-output setter kept for compatibility with callers that expect setType
                this.setType = function(type) {
                    ensureSlotCounts(this);
                    if (this.outputs[0]) {
                        this.outputs[0].name = type;
                        this.outputs[0].type = type;
                    }
                    this.validateLinks();
                }

                this.goToSetter = function() {
                    const setter = findSetter(this);
                    if (setter) {
                        this.canvas.centerOnNode(setter);
                        this.canvas.selectNode(setter, false);
                    }
                };
                
                this.updateTitle = function() {
                    console.log("[GetTwinNodes] updateTitle");
                    const namesForTitle = extractWidgetNames(this);
                    this.title = computeTwinNodeTitle(namesForTitle, "Get", disablePrefix);

                    // Determine colors using all connected input types in order
                    const typesArr = (this.outputs || [])
                        .filter(inp => inp?.link != null && inp?.type && inp.type !== '*')
                        .map(inp => inp.type);
                    
                    // Note: we don't actually have a settings panel yet
                    const autoColor = app.ui.settings.getSettingValue("KJNodes.nodeAutoColor");
                    if (typesArr.length && autoColor) {
                        setColorAndBgColor.call(this, typesArr);
                    } else {
                        // reset to default look if nothing connected or auto-color disabled
                        this.color = undefined;
                        this.bgcolor = undefined;
                    }
                }

                // This node is purely frontend and does not impact the resulting prompt so should not be serialized
                this.isVirtualNode = true;
            }


// TODO: This function doesn't work for shit on the second widget, because findSetter isn't that smart
            /**
             * Returns the link connected to the matched setter's input corresponding to the given output slot.
             * This is a convenience helper specific to GetTwinNodes.
             * @param {number} slot Output slot index on this getter.
             * @returns {LLink|undefined} The found link, or undefined if no matching setter/link exists.
             */
            getInputLink(slot) {
                const setter = findSetter(this, this.widgets[slot].value);

                if (setter) {
                    const input = setter.inputs[slot];
                    const link = GraphHelpers.getLink(this.graph, input.link);
                    return link;
                } else {
                    // No SetTwinNodes found for BOOLEAN(GetTwinNodes). Most likely you're missing custom nodes
                    const errorMessage = "No SetTwinNode found for the first input (" + this.widgets[slot].value + ") of the GetTwinNodes titled " + this.title;
                    showAlert(errorMessage, {
                        summary: "GetTwinNodes Error",
                        severity: "error",
                        detail: errorMessage,
                    });

                    this.canvas.centerOnNode(this);
                    this.canvas.selectNode(this, false);
                    //throw new Error(errorMessage);
                }
            }
            /**
             * Called when the node is added to a graph.
             * Mirrors LGraphNode.onAdded.
             * @param {LGraph} graph The graph this node was added to.
             * @returns {void}
             */
            onAdded(graph) {
                if (Array.isArray(this.widgets)) {
                    for (let i = 0; i < this.widgets.length; i++) {
                        try { wrapWidgetValueSetter(this.widgets[i]); } catch (_e) {}
                    }
                }
            }

            /**
             * Allows extending the context menu for this node.
             * Mirrors LGraphNode.getExtraMenuOptions contract by receiving the canvas and a mutable options array.
             * @param {LGraphCanvas} _ The graph canvas (unused here).
             * @param {ContextMenuItem[]} options Array of context menu option entries to extend in place.
             * @returns {void}
             */
            getExtraMenuOptions(_, options) {
                const node = this;
                let menuEntry = node.drawConnection ? "Hide connections" : "Show connections";

                options.unshift(
                    {
                        content: "Go to setter",
                        callback: () => {
                            node.goToSetter();
                        },
                    },
                    {
                        content: menuEntry,
                        callback: () => {
                            node.currentSetter = findSetter(node);
                            console.log("[GetTwinNodes] context menu, found setters", node.currentSetter);
                            if (!node.currentSetter) return;
                            // Generalize: pick first typed input on setter
                            let linkType = '*';
                            if (Array.isArray(node.currentSetter.inputs)) {
                                const fin = node.currentSetter.inputs.find(i => i && i.type && i.type !== '*');
                                if (fin) linkType = fin.type;
                            }
                            node.drawConnection = !node.drawConnection;
                            node.slotColor = node.canvas.default_connection_color_byType[linkType]
                            menuEntry = node.drawConnection ? "Hide connections" : "Show connections";
                            node.canvas.setDirty(true, true);
                        },
                    },
                );
            }

            /**
             * Called to render custom content on top of the node after the node background/body has been drawn.
             * Mirrors LGraphNode.onDrawForeground.
             * @param {CanvasRenderingContext2D} ctx Canvas 2D rendering context.
             * @param {LGraphCanvas} lGraphCanvas The graph canvas.
             * @returns {void}
             */
            onDrawForeground(ctx, lGraphCanvas) {
                if (this.drawConnection) {
                    this._drawVirtualLink(lGraphCanvas, ctx);
                }
            }
            // onDrawCollapsed(ctx, lGraphCanvas) {
            // 	if (this.drawConnection) {
            // 		this._drawVirtualLink(lGraphCanvas, ctx);
            // 	}
            // }
            _drawVirtualLink(lGraphCanvas, ctx) {
                if (!this.currentSetter) return;

                // Provide a default link object with necessary properties, to avoid errors as link can't be null anymore
                const defaultLink = { type: 'default', color: this.slotColor };

                // Choose first typed input on setter as anchor (fallback to slot 0)
                let inIdx = 0;
                if (Array.isArray(this.currentSetter.inputs)) {
                    const fin = this.currentSetter.inputs.findIndex(i => i && i.type && i.type !== '*');
                    if (fin >= 0) inIdx = fin;
                }
                const absStart = this.currentSetter.getConnectionPos(false, inIdx);
                const start_node_slotpos = [
                    absStart[0] - this.pos[0],
                    absStart[1] - this.pos[1],
                ];

                // End near our header (consistent with prior behavior)
                const end_node_slotpos = [0, -LiteGraph.NODE_TITLE_HEIGHT * 0.5];

                lGraphCanvas.renderLink(
                    ctx,
                    start_node_slotpos,
                    end_node_slotpos,
                    defaultLink,
                    false,
                    null,
                    this.slotColor
                );
            }
        }

        LiteGraph.registerNodeType(
            "GetTwinNodes",
            Object.assign(GetTwinNodes, {
                title: "Get",
            })
        );

        GetTwinNodes.category = "ovum";
    },
});
